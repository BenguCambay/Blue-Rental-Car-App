pipeline {
    agent any

    parameters {
        choice(name: 'ENVIRONMENT', choices: ['default', 'test', 'dev', 'prod', 'staging'], description: 'Select the target environment')
        string(name: 'INSTANCE_TYPE', defaultValue: 't2.micro', description: 'AWS EC2 instance type')
        string(name: 'INSTANCE_COUNT', defaultValue: '1', description: 'Number of instances to deploy, must be a positive number')
    }

    environment {
        KUBECONFIG = "/etc/rancher/k3s/k3s.yaml"
        FRONTEND_TAG = "frontend-v${BUILD_NUMBER}"
        BACKEND_TAG = "backend-v${BUILD_NUMBER}"
        DB_TAG = "postgre-v${BUILD_NUMBER}"
        AWS_REGION = "us-east-1"
        INSTANCE_COUNT_INT = "${params.INSTANCE_COUNT.toInteger()}"
        APP_NAME = "car-rental"
        APP_REPO_NAME = "task-4-ecr-repo"
        AWS_ACCOUNT_ID = sh(script: 'export PATH="$PATH:/usr/local/bin" && aws sts get-caller-identity --query Account --output text', returnStdout: true).trim()
        ECR_REGISTRY = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
    }

    stages {    
        stage('Create Key Pair for AWS instance') {
            steps {
                echo "Creating Key Pair "
                sh """
                    aws ec2 create-key-pair --region ${AWS_REGION} --key-name ${ENVIRONMENT} --query KeyMaterial --output text > ${ENVIRONMENT}
                    chmod 400 ${ENVIRONMENT}
                """
            }
        }
        
        stage('Create AWS Resources') {
            steps {
                sh """
                    cd Task-4/terraform
                    terraform workspace select ${params.ENVIRONMENT} || terraform workspace new ${params.ENVIRONMENT}
                    terraform init
                    terraform apply -var='ec2_type=${params.INSTANCE_TYPE}' \
                                    -var='num_of_instance=${INSTANCE_COUNT_INT}' \
                                    -var='ec2_key=${ENVIRONMENT}' \
                                    -auto-approve
                """
            }
        }

        stage('Create ECR Repository') {
            steps {
                echo "Creating ECR Repository ${APP_REPO_NAME}"
                sh """
                    aws ecr describe-repositories --repository-names "${APP_REPO_NAME}" --region ${AWS_REGION} || \
                    aws ecr create-repository --repository-name "${APP_REPO_NAME}" --region ${AWS_REGION}
                """
            }
        }

        stage('Build') {
            steps {
                script {
                    env.IMAGE_TAG_FE = "${ECR_REGISTRY}/${APP_REPO_NAME}:${FRONTEND_TAG}"
                    env.IMAGE_TAG_BE = "${ECR_REGISTRY}/${APP_REPO_NAME}:${BACKEND_TAG}"
                    env.IMAGE_TAG_DB = "${ECR_REGISTRY}/${APP_REPO_NAME}:${DB_TAG}"
                    echo "Image Tag: ${env.IMAGE_TAG_FE}"
                    echo "Image Tag: ${env.IMAGE_TAG_BE}"
                    echo "Image Tag: ${env.IMAGE_TAG_DB}"
                }
            }
        }

        stage('Build App Docker Images') {
            steps {
                echo 'Building App Images'
                sh """
                    docker build --force-rm -t "${IMAGE_TAG_FE}" "${WORKSPACE}/Task-4/bluerentalcars-frontend"
                    docker build --force-rm -t "${IMAGE_TAG_BE}" "${WORKSPACE}/Task-4/bluerentalcars-backend"
                    docker build --force-rm -t "${IMAGE_TAG_DB}" "${WORKSPACE}/Task-4/postgresql"
                    docker image ls
                """
            }
        }

        stage('Push Images to ECR Repo') {
            steps {
                echo "Pushing ${APP_NAME} App Images to ECR Repo"
                sh """
                    aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ECR_REGISTRY}
                    docker push "${IMAGE_TAG_FE}"
                    docker push "${IMAGE_TAG_BE}"
                    docker push "${IMAGE_TAG_DB}"
                """
            }
        }

        stage('Create ENV NODE_IP') {
            steps {
                echo 'Creating ENV'
                dir('Task-4/terraform') {
                    script {
                        env.NODE_IP = sh(script: 'terraform output -raw public_ip', returnStdout: true).trim()
                    }
                }
                sh "echo ${NODE_IP}"
            }
        }

        stage('ENVSUBST UPDATE') {
            steps {
                echo 'Updating environment configurations'
                sh """
                    cd Task-4/kubernetes-yml
                    envsubst < ui-deployment-template.yaml > ui-deployment.yaml
                    envsubst < kustomization-template.yaml > kustomization.yaml
                """
            }
        }

        stage('Wait for the instance') {
            steps {
                script {
                    echo 'Waiting for the instance'
                    id = sh(script: 'aws ec2 describe-instances --filters Name=tag-value,Values="${ENVIRONMENT}_server" Name=instance-state-name,Values=running --query Reservations[*].Instances[*].[InstanceId] --output text', returnStdout: true).trim()
                    sh 'aws ec2 wait instance-status-ok --instance-ids $id'
                }
            }
        }

        stage('Configure AWS Instance and Deploy Application') {
            steps {
                echo 'Configuring AWS Instance'
                sh 'ls -l'
                sh 'ansible --version'
                sh 'ansible-inventory -i ./Task-4/ansible/inventory_aws_ec2.yml --graph'
                sh """
                    cd Task-4/ansible
                    ansible-playbook -i inventory_aws_ec2.yml --private-key="${WORKSPACE}/${ENVIRONMENT}" -e "compose_dir=${WORKSPACE}/Task-4/docker" ${ENVIRONMENT}.yml -vv
                """
            }
        }

        stage('Apply Kubernetes Configurations') {
            steps {
                script {
                    env.sshKeyFile = "${WORKSPACE}/${ENVIRONMENT}"
                    echo "SSH Key File Path: ${sshKeyFile}"
                    sh """
                       scp -i ${sshKeyFile} -o StrictHostKeyChecking=no ${WORKSPACE}/Task-4/kubernetes-yml/* ubuntu@${NODE_IP}:/home/ubuntu/kubernetes-yml/
                       """


                    sh """
                       ssh -i ${sshKeyFile} -o StrictHostKeyChecking=no ubuntu@${NODE_IP} '
                       sleep 10
                       rm -rf /home/ubuntu/kubernetes-yml/kustomization-template.yaml
                       rm -rf /home/ubuntu/kubernetes-yml/ui-deployment-template.yaml
                       export KUBECONFIG=${KUBECONFIG}
                       kubectl apply -k /home/ubuntu/kubernetes-yml/
                       '
                    """
                }
            }
        }
    }

    post {
        always {
            echo 'Deleting all local images'
            sh 'docker image prune -af'
        }
        success {
            echo 'Deleting Key Pair'
            timeout(time: 5, unit: 'DAYS') {
                input message: 'Approve termination'
            }
            sh """
                aws ec2 delete-key-pair --region ${AWS_REGION} --key-name ${ENVIRONMENT}
                rm -rf ${ENVIRONMENT}
            """
            echo 'Deleting AWS Resources'            
            sh """
                cd Task-4/terraform
                terraform destroy --auto-approve
            """
            echo 'Deleting the Image Repository on ECR after success'
            sh "aws ecr delete-repository --repository-name ${APP_REPO_NAME} --region ${AWS_REGION} --force"
        }
        failure {
            echo 'Deleting Key Pair'
            timeout(time: 5, unit: 'DAYS') {
                input message: 'Approve termination'
            }
            sh """
                aws ec2 delete-key-pair --region ${AWS_REGION} --key-name ${ENVIRONMENT}
                rm -rf ${ENVIRONMENT}
            """
            echo 'Deleting AWS Resources'            
            sh """
                cd Task-4/terraform
                terraform destroy --auto-approve
            """
            echo 'Deleting the Image Repository on ECR after failure'
            sh "aws ecr delete-repository --repository-name ${APP_REPO_NAME} --region ${AWS_REGION} --force"
        }
    }
}
